package com.rest;

public class Lesson_53_Rest_api_meeting {
    // Начинаем новую, обширную тему связанную со способами передачи, обработки информации и
    // транспортным протоколами, забегая немного вперед, отметим, что почти всегда это касается HTTP.

    // REST(Representational State Transfer) - дословно переводится как передача состояния представления.
    // Эта технология позволяет получать и модифицировать данные и состояния удаленных приложений,
    // посредством HTTP вызовов. Если проще, это процесс передачи информации от сервера клиенту по
    // заданному url, где определенны свои правила и условия.

    // API(Application Programming Interface) - дословно, программный интерфейс приложения.
    // Это набор инструментов, который позволяет клиенту взаимодействовать с сервером, либо наоборот.
    // API предусматривает возможность взаимодействия удаленно, то есть приложения могут запрашивать
    // функции друг друга удаленно. Так же API должен учитывать, что программы могут быть написаны на
    // разных языках программирования.

    // REST, по определению его создателя(кстати, он же создатель HTTP, что определяет
    // предрасположенность стиля REST к работе с этим протоколом) при правильном проектировании
    // обладает набором свойств: Производительность, масштабируемость, Гибкость к изменениям,
    // отказоустойчивость, простота поддержки. Это основные свойства, на деле их гораздо больше.

    // REST имеет 6 основных принципов(ограничений), которые помогают добиться этих свойств:

    // 1) Клиент-серверная архитектура - без комментариев, имея один сервер и множество
    // подключаемых к нему клиентов, мы можем спокойно внедрять изменения в коде, не требуя
    // от клиента при этом обновиться. Как пример, мы захотели внедрить базу данных в наше приложение.
    // Код для этого достаточно написать на самом сервере, клиенту необязательно об этом знать.
    // Такой подход гарантирует масштабируемость и определенную простоту поддержки. Производительность
    // зависит сугубо от мощности сервера, при необходимости мы можем расширить его мощности
    // незаметно для клиента. Однако в таком подходе есть и минус: сервер является единой точкой
    // отказа, при недоступности сервера, клиенты тоже не смогут корректно работать. Но такие
    // проблемы обычно решаются реплицированием, что несколько снижает производительность, но
    // предоставляет отказоустойчивость.
    // 2) Stateless(отсутствие состояний) - этот принцип заключается в том, что сервер не должен
    // хранить у себя информацию о сессии с клиентом.
    // В каждом запросе он должен получать всю информацию для обработки.
    // Имеется обратное понятие - Stateful. При этом принципе сервер сохраняет какую то информацию
    // о взаимодействии с клиентом, на основе чего может реализовывать какую-то логику при схожих
    // запросах.
    // Но в REST должен использоваться Stateless подход. Его плюсы: масштабируемость сервера,
    // уменьшение времени обработки запроса, простота поддержки, возможность использовать кеширование,
    // о кешировании мы поговорим позже, отдельно. Его минусы: усложнение логики клиента, именно
    // клиент должен хранить информацию о состояниях, допустимых и недопустимых действиях, а так же
    // увеличение нагрузки на сеть, каждый раз мы передаем всю доступную информацию.
    // 3) Кеширование - этот подход позволяет избегать однотипных запросов. Представим ситуацию,
    // когда наш сервер получив запрос обращается для ответа к другому ресурсу в сети, если подобных
    // однотипных запросов много, то имеет смысл хранить эту информацию на сервере, уменьшая количество
    // взаимодействий по сети. Плюсы: в определенных случаях дает прирост производительности,
    // уменьшает нагрузку на системы. Минусы: достаточна сложная для реализации вещь, имеет
    // ограничения по использованию, часто просто нет смысла использовать кеширование.
    // 4) Единообразие интерфейса(HATEOAS - Hypermedia as the Engine of Application State) -
    // согласно этому ограничению сервер вернет не только ресурс по запросу, но и его связи
    // с другими ресурсами и возможные действия с ними, а так же все связанные объекты с этими
    // ресурсами и так по цепочке. Получая такой ответ клиент сам понимает какие действия
    // он может провести с объектом и со всеми его связями. Логика клиента становится более гибкой,
    // но и более сложной, эта гибкость и есть главный плюс, однако это же и является минусом,
    // ответственность за действия клиента, мы перекладываем на его плечи, ослабляем контроль
    // валидности совершаемых операций на сервере.
    // 5) Слоистая архитектура(Layered system) - до этого мы рассматривали клиент-серверную
    // архитектуру, однако в реальной жизни между клиентом и сервером существуют посредники,
    // прокси сервера, балансировщики, роутеры и т.д. Концепция слоистой архитектуры подразумевает,
    // что ни сервер ни клиент не знают об этих посредниках. Минусами можно определить увеличение
    // нагрузки на сеть и увеличение времени получения ответа.
    // 6) Код-по-требованию(Code on done) - этот подход позволяет передавать куски кода от
    // сервера клиенту, а тот уже сам их обрабатывает. Такой подход, опять же делает
    // клиент гибче, но валидацию он должен проводить сам.

    // Итак, подытоживая нашу лекцию мы можем сказать так: REST, это парадигма, которая помогает
    // нам выявить и определить важнейшие свойства архитектуры - масштабируемость, производительность
    // и т.д.
}
